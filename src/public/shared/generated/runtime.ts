/* tslint:disable */
/* eslint-disable */
import { ErrorResponse } from "./models";
import { AuthSessionState } from "../../../private/AuthSessionState";
import { ConsoleUtils } from "../../../private/ConsoleUtils";
import { FilePathUtils } from "../../../private/FilePathUtils";

/**
 * @bytescale/api
 * Bytescale API
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: hello@bytescale.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

export interface BytescaleApiClientConfig {
  /**
   * Only required for Node.js. Must be an instance of requires("node-fetch").
   *
   * Not required for the browser.
   */
  fetchApi?: FetchAPI;

  /**
   * Must begin with "public_" or "secret_".
   *
   * Please note: if you require JWT-based auth, you must provide an API key to this field, and then call 'AuthManager.beginAuthSession' to start a JWT-based auth session. The JWT's permissions will be merged with the API key's permissions, with precedence given to the JWT.
   */
  apiKey: string;

  /**
   * The base URL of the Bytescale API. (Excludes trailing "/".)
   */
  apiUrl?: string;

  /**
   * The base URL of the Bytescale CDN. (Excludes trailing "/".)
   */
  cdnUrl?: string;

  /**
   * Enables additional debug information.
   */
  debug?: boolean;

  /**
   * Headers to include in all API requests.
   *
   * These headers take precedence over any headers automatically added by the SDK (e.g. "Authorization", "Content-Type", etc.).
   */
  headers?: HTTPHeaders | (() => Promise<HTTPHeaders> | HTTPHeaders); // This should be present on all Bytescale SDKs, as it's how we instruct users to pass the "Authorization-Token" request header for non-cookie-based JWT auth.
}

export class BytescaleApiClientConfigUtils {
  static defaultApiUrl = "https://api.bytescale.com";
  static defaultCdnUrl = "https://upcdn.io";
  private static readonly specialApiKeys = ["free", "demo"];
  private static readonly specialApiKeyAccountId = "W142hJk";
  private static readonly accountIdLength = 7; // Sync with: upload/shared/**/AccountIdUtils

  static getApiUrl(config: BytescaleApiClientConfig): string {
    return config.apiUrl ?? BytescaleApiClientConfigUtils.defaultApiUrl;
  }

  static getCdnUrl(config: Pick<BytescaleApiClientConfig, "cdnUrl">): string {
    return config.cdnUrl ?? BytescaleApiClientConfigUtils.defaultCdnUrl;
  }

  static getFetchApi(config: Pick<BytescaleApiClientConfig, "fetchApi">): FetchAPI {
    return config.fetchApi ?? fetch;
  }

  static getAccountId(config: Pick<BytescaleApiClientConfig, "apiKey">): string {
    let accountId: string;

    if (BytescaleApiClientConfigUtils.specialApiKeys.includes(config.apiKey)) {
      accountId = BytescaleApiClientConfigUtils.specialApiKeyAccountId;
    } else {
      accountId = config.apiKey.split("_")[1]?.substr(0, BytescaleApiClientConfigUtils.accountIdLength) ?? "";
      if (accountId.length !== BytescaleApiClientConfigUtils.accountIdLength) {
        throw new Error(`Invalid Bytescale API key.`);
      }
    }

    return accountId;
  }

  static validate(config: BytescaleApiClientConfig): void {
    // Defensive programming, for users not using TypeScript. Mainly because this is used by UploadWidget users.
    if ((config ?? undefined) === undefined) {
      throw new Error(`Config parameter required.`);
    }
    if ((config.apiKey ?? undefined) === undefined) {
      throw new Error(`Please provide an API key via the 'apiKey' config parameter.`);
    }
    if (config.apiKey.trim() !== config.apiKey) {
      // We do not support API keys with whitespace (by trimming ourselves) because otherwise we'd need to support this
      // everywhere in perpetuity (since removing the trimming would be a breaking change).
      throw new Error(`API key needs trimming (whitespace detected).`);
    }

    // This performs futher validation on the API key...
    BytescaleApiClientConfigUtils.getAccountId(config);
  }
}

/**
 * This is the base class for all generated API classes.
 */
export class BaseAPI {
  constructor(protected readonly config: BytescaleApiClientConfig) {
    BytescaleApiClientConfigUtils.validate(config);
  }

  /**
   * Returns a successful response (2**) else throws an error.
   */
  static async fetch(
    url: string,
    init: RequestInit,
    config: Pick<BytescaleApiClientConfig, "fetchApi" | "debug"> & { isBytescaleApi: boolean }
  ): Promise<Response> {
    let response: Response;
    try {
      response = await BytescaleApiClientConfigUtils.getFetchApi(config)(url, {
        ...init,

        // This is specifically added to cater for Next.js's Fetch implementation, which caches POST requests...
        //
        // "fetch requests that use the POST method are also automatically cached."
        // - https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating#caching-data
        //
        // However, this is probably a good idea, even for all GET requests, as if the user is refreshing a JWT
        // or downloading a file via 'FileApi.downloadFile', then they'll likely want the latest.
        cache: "no-store",

        // Node does not support full duplex, so default fetch implementations will fail with "RequestInit: duplex option is required when sending a body"
        // unless the following is set.
        // https://github.com/nodejs/node/issues/46221#issuecomment-1383246036
        duplex: "half"
      });
    } catch (e) {
      // Network-level errors, CORS errors, or HTTP-level errors from intermediary services (e.g. AWS or the user's own infrastructure/proxies).
      // HTTP-level errors from external services (e.g. AWS or the user's own proxy) will appear as CORS errors as their response headers won't include the appropriate CORS values.
      throw new Error(
        config.isBytescaleApi
          ? `Unable to resolve the Bytescale API: ${
              (e as Error).message
            } If the problem persists, and your network connection is OK, then please contact support@bytescale.com and provide: (a) time of failed request in UTC (b) screenshot of failed network response header + body (c) screenshot of failed network request header + body (d) browser and OS version.`
          : `Unable to resolve URL (${url}): ${(e as Error).message}`
      );
    }

    if (response.status >= 200 && response.status < 300) {
      return response;
    }

    if (config.isBytescaleApi) {
      let errorText = undefined;
      let errorJson = undefined;
      try {
        errorText = await response.text();
        errorJson = JSON.parse(errorText);
      } catch (_e) {
        // Error will be thrown below.
      }
      if (typeof errorJson?.error?.code === "string") {
        throw new BytescaleApiError(errorJson as ErrorResponse);
      }

      if (config.debug === true) {
        ConsoleUtils.debug("Error response header:");
        response.headers.forEach((headerValue, headerKey) => ConsoleUtils.debug(`${headerKey}: ${headerValue}`));
        ConsoleUtils.debug("Error response body:");
        ConsoleUtils.debug(errorText ?? "<empty>");
      }

      // HTTP-level errors from intermediary services (e.g. AWS or the user's own infrastructure/proxies). On the browser,
      // this error is unlikely to be triggered since these errors will masqurade as CORS errors (see above) but in Node.js
      // this error will appear from any intermediary service failure. Also occurs when calling ProcessFile for an
      // asynchronous media job, where the transformation is initiated using the primary artifact: in this instance,
      // a 404 JSON response is returned containing the transformation job until it completes.
      throw new BytescaleGenericError(response, errorText, errorJson);
    }

    throw new Error(`Failure status code (${response.status}) received for request: ${init.method ?? "GET"} ${url}`);
  }

  protected async request(
    context: RequestOpts,
    initOverrides: RequestInit | InitOverrideFunction | undefined,
    baseUrlOverride: string | undefined
  ): Promise<Response> {
    const apiKey = this.config.apiKey;
    context.headers["Authorization"] = `Bearer ${apiKey}`; // authorization-header authentication

    const session = AuthSessionState.getSession();
    if (session?.accessToken !== undefined) {
      context.headers["Authorization-Token"] = session.accessToken;
    }

    // Key: any possible value for 'baseUrlOverride'
    // Value: user-overridden value for that base URL from the config.
    const nonDefaultBasePaths = {
      [BytescaleApiClientConfigUtils.defaultCdnUrl]: BytescaleApiClientConfigUtils.getCdnUrl(this.config)
    };

    const { url, init } = await this.createFetchParams(
      context,
      initOverrides,
      baseUrlOverride === undefined ? undefined : nonDefaultBasePaths[baseUrlOverride] ?? baseUrlOverride
    );

    return BaseAPI.fetch(url, init, { ...this.config, isBytescaleApi: true });
  }

  protected encodePathParam(paramName: string, paramValue: string): string {
    if (paramName === "filePath") {
      if (!paramValue.startsWith("/")) {
        // Non-obvious errors are returned by the Bytescale CDN if forward slashes are omitted, so catch it client-side:
        throw new Error("The 'filePath' parameter must begin with a '/' character.");
      }
      return FilePathUtils.encodeFilePath(paramValue);
    }

    return encodeURIComponent(paramValue);
  }

  private async createFetchParams(
    context: RequestOpts,
    initOverrides: RequestInit | InitOverrideFunction | undefined,
    baseUrlOverride: string | undefined
  ) {
    let url = (baseUrlOverride ?? BytescaleApiClientConfigUtils.getApiUrl(this.config)) + context.path;
    if (context.query !== undefined && Object.keys(context.query).length !== 0) {
      // only add the querystring to the URL if there are query parameters.
      // this is done to avoid urls ending with a "?" character which buggy webservers
      // do not handle correctly sometimes.
      url += "?" + querystring(context.query);
    }
    const configHeaders = this.config.headers;
    const headers = {
      ...context.headers,
      // Headers from config take precedence, to allow us to override the "Authorization" header (which is added earlier
      // on) with a JWT session token.
      ...(configHeaders === undefined
        ? {}
        : typeof configHeaders === "function"
        ? await configHeaders()
        : configHeaders)
    };
    Object.keys(headers).forEach(key => (headers[key] === undefined ? delete headers[key] : {}));

    const initOverrideFn = typeof initOverrides === "function" ? initOverrides : async () => initOverrides;

    const initParams = {
      method: context.method,
      headers,
      body: context.body
    };

    const overriddenInit: RequestInit = {
      ...initParams,
      ...(await initOverrideFn({
        init: initParams,
        context
      }))
    };

    const init: RequestInit = {
      ...overriddenInit,
      body: JSON.stringify(overriddenInit.body)
    };

    return { url, init };
  }
}

export class CancelledError extends Error {
  override name: "CancelledError" = "CancelledError";

  constructor() {
    super("Operation cancelled by caller.");
  }
}

/**
 * Thrown when the Bytescale API cannot be reached or when an error is returned that cannot be parsed as a JSON error response.
 */
export class BytescaleGenericError extends Error {
  override name: "BytescaleGenericError" = "BytescaleGenericError";
  constructor(
    public readonly response: Response,
    public readonly responseText: string | undefined,
    public readonly responseJson: object | undefined
  ) {
    super(`Unable to connect to the Bytescale API (${response.status}): please try again.`);
  }
}

/**
 * Thrown when the Bytescale API returns a JSON error response.
 */
export class BytescaleApiError extends Error {
  override name: "BytescaleApiError" = "BytescaleApiError";
  public readonly errorCode: string;
  public readonly details: any | undefined;

  constructor(response: ErrorResponse) {
    super(response.error.message);

    this.errorCode = response.error.code;
    this.details = response.error.details;
  }
}

export type FetchAPI = (input: RequestInfo | URL, init?: RequestInit & { duplex: "half" }) => Promise<Response>;

export type Json = any;
export type HTTPMethod = "GET" | "POST" | "PUT" | "PATCH" | "DELETE" | "OPTIONS" | "HEAD";
export type HTTPHeaders = { [key: string]: string };
export type HTTPQuery = {
  [key: string]: string | number | null | boolean | HTTPQuery;
};
export type HTTPBody = Json | FormData | URLSearchParams;
export type HTTPRequestInit = { headers?: HTTPHeaders; method: HTTPMethod; body?: HTTPBody };

export type InitOverrideFunction = (requestContext: {
  init: HTTPRequestInit;
  context: RequestOpts;
}) => Promise<RequestInit>;

export interface RequestOpts {
  path: string;
  method: HTTPMethod;
  headers: HTTPHeaders;
  query?: HTTPQuery;
  body?: HTTPBody;
}

function moveElementToEnd<T>(array: T[], element: T): T[] {
  return [...array.filter(x => x !== element), ...array.filter(x => x === element)];
}

export function querystring(params: HTTPQuery): string {
  // The 'artifact' param must be the last param for certain transformations, such as async HLS jobs. For example,
  // given an artifact '!f=hls-h264&artifact=/video.m3u8' that returns a master M3U8 playlist containing relative
  // links to child M3U8 playlists (e.g. 'child1.m3u8'), when the child URLs inside the master M3U8 file are resolved
  // by the browser, the 'child1.m3u8' path essentially replaces everything after the '/' on the master M3U8 URL.
  // Thus, if query params existed after the 'artifact' param, they would be wiped out, causing the child M3U8
  // playlist to suddenly reference a different transformation.
  const keysReordered = moveElementToEnd(Object.keys(params), "artifact");

  return keysReordered
    .map(key => querystringSingleKey(key, params[key]))
    .filter(part => part.length > 0)
    .join("&");
}

function querystringSingleKey(key: string, value: string | number | null | undefined | boolean | HTTPQuery): string {
  if (value instanceof Object) {
    // Matches 'array' or 'object' (which we want).
    return querystring(value as HTTPQuery);
  }
  return encodeBytescaleQuerystringKVP(key, String(value));
}

/**
 * Handles artifacts specially as these must use "/" instead of "%2F" in order for relative paths within the artifact's
 * contents to work (assumes user has replaced "?" with "!"). For example, M3U8 artifacts that contain relative URLs to
 * other M3U8s and/or media segments will only work if the user replaces "?" with "!" in the URL _and_ the artifact
 * query param value has been written using "/" instead of "%2F", as this then means the URLs become relative to the
 * artifact, as opposed to the file path.
 */
export function encodeBytescaleQuerystringKVP(key: string, value: string) {
  if (key === "a" || key === "artifact") {
    return `${key}=${encodeURIComponent(value).replace(/%2F/g, "/")}`;
  }
  return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
}

export interface ApiResponse<T> {
  raw: Response;
  value(): Promise<T>;
}

export class JSONApiResponse<T> {
  constructor(public raw: Response) {}

  async value(): Promise<T> {
    return await this.raw.json();
  }
}

export class VoidApiResponse {
  constructor(public raw: Response) {}

  async value(): Promise<void> {
    return undefined;
  }
}

export class BinaryResult {
  constructor(public raw: Response) {}

  stream(): ReadableStream<Uint8Array> {
    if (this.raw.bodyUsed) {
      throw new Error("Response body has already been consumed.");
    }
    if (this.raw.body === null) {
      throw new Error("Response body does not exist.");
    }
    return this.raw.body;
  }

  async text(): Promise<string> {
    return await this.raw.text();
  }

  async blob(): Promise<Blob> {
    return await this.raw.blob();
  }

  async json(): Promise<any> {
    return await this.raw.json();
  }
}
