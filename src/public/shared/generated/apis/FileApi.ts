/* tslint:disable */
/* eslint-disable */
/**
 * @bytescale/api
 * Bytescale API
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: hello@bytescale.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

// @ts-ignore
import * as runtime from "../runtime";
import type {
  // @ts-ignore
  AsyncResponse,
  // @ts-ignore
  CopyFileBatchRequest,
  // @ts-ignore
  CopyFileRequest,
  // @ts-ignore
  CopyFileResponse,
  // @ts-ignore
  DeleteFileBatchRequest,
  // @ts-ignore
  ErrorResponse,
  // @ts-ignore
  FileDetails,
  // @ts-ignore
  ProcessFileAndSaveRequest,
  // @ts-ignore
  ProcessFileAndSaveResponse,
  // @ts-ignore
  ProcessFileTransformationParamsParameterValue
} from "../models";

export interface CopyFileOperationParams {
  accountId: string;

  copyFileRequest: CopyFileRequest;
}

export interface CopyFileBatchOperationParams {
  accountId: string;

  copyFileBatchRequest: CopyFileBatchRequest;
}

export interface DeleteFileParams {
  accountId: string;

  filePath: string;
}

export interface DeleteFileBatchOperationParams {
  accountId: string;

  deleteFileBatchRequest: DeleteFileBatchRequest;
}

export interface DownloadFileParams {
  accountId: string;

  filePath: string;

  /**
   * Specifies whether to cache the raw file in the Bytescale CDN.
   *
   * Default: true
   */
  cache?: boolean;

  /**
   * Specifies the maximum amount of time, in seconds, the file will be cached on the user's device and in the Bytescale CDN's edge cache.
   *
   * Default: Please refer to your account's default cache settings in the Bytescale Dashboard.
   */
  cacheTtl?: number;

  /**
   * Downloads the latest version of your file (if you have overwritten it) when added to the URL with a unique value.
   *
   *   The value of the `version` parameter can be anything, e.g. an incremental number, a timestamp, etc.
   *
   *   You only need to provide and update this value if/when you overwrite your file.
   */
  version?: string;
}

export interface GetFileDetailsParams {
  accountId: string;

  filePath: string;
}

export interface ProcessFileParams {
  accountId: string;

  filePath: string;

  /**
   * The name of the File Processing API (e.g. "image", "video", "audio") or transformation preset (created in the Bytescale Dashboard) to use when processing the file.
   */
  transformation: string;

  /**
   * Some transformations output multiple files, called artifacts.
   *
   * You can download each individual transformation artifact by specifying its path with this parameter
   */
  artifact?: string;

  /**
   * Specifies whether to cache the transformed result.
   *
   * If set to `false` the transformation will be executed on every request.
   *
   * *Recommendation:* instead of disabling the cache, a more performant solution is to use the `version` parameter and to increment it each time you require an updated result.
   *
   * Default: true
   */
  cache?: boolean;

  /**
   * Specifies whether to cache the transformed result in the Bytescale CDN perma-cache.
   *
   * Perma-caching works by storing your file permanently, or until a manual cache purge is performed.
   *
   * When `cache=false` this parameter is automatically set to `false`.
   *
   * When `cache_perm=auto` the perma-cache will only be used for files that take more than 1000ms to process.
   *
   * When the perma-cache is used, approximately 200ms of latency is added to the initial request. Thereafter, files will be served from the Bytescale CDN's edge cache or perma-cache, so will have minimal latency.
   *
   * Default: Please refer to your account's default cache settings in the Bytescale Dashboard.
   */
  cachePerm?: ProcessFileCachePermEnum;

  /**
   * Specifies the maximum amount of time, in seconds, the transformed result will be cached on the user's device and in the Bytescale CDN's edge cache.
   *
   * If the file is perma-cached, then the file will not be reprocessed on edge cache misses.
   *
   * If the file is not perma-cached, then the file will be reprocessed on edge cache misses.
   *
   * For more information on perma-caching, see: `cache_perm`
   *
   * Default: Please refer to your account's default cache settings in the Bytescale Dashboard.
   */
  cacheTtl?: number;

  /**
   * Parameters to submit to the File Processing API (e.g. the Image Processing API).
   *
   * Please see the documentation for each File Processing API to determine which values can appear here:
   *
   * - https://www.bytescale.com/docs/image-processing-api
   * - https://www.bytescale.com/docs/video-processing-api
   * - https://www.bytescale.com/docs/audio-processing-api
   * - https://www.bytescale.com/docs/archive-processing-api
   */
  transformationParams?: { [key: string]: ProcessFileTransformationParamsParameterValue };

  /**
   * Add this parameter and increment its value to force the file to be reprocessed.
   *
   * The Bytescale CDN caches files based on the full URL (including the querystring), meaning this parameter is useful when dealing with changes made to transformation presets. By contrast, File Processing APIs (like the Image Processing API) shouldn't ever require this parameter, since the URL/querystring naturally changes each time you adjust a parameter, causing a cache miss and the file to be reprocessed with the new querystring parameters.
   *
   * The value of the `version` parameter can be anything, e.g. an incremental number, a timestamp, etc.
   *
   * You only need to provide and update this value if/when you make changes to a transformation preset's settings.
   */
  version?: string;
}

export interface ProcessFileAndSaveOperationParams {
  accountId: string;

  filePath: string;

  /**
   * The name of the File Processing API (e.g. "image", "video", "audio") or transformation preset (created in the Bytescale Dashboard) to use when processing the file.
   */
  transformation: string;

  /**
   *
   */
  processFileAndSaveRequest: ProcessFileAndSaveRequest;

  /**
   * Parameters to submit to the File Processing API (e.g. the Image Processing API).
   *
   * Please see the documentation for each File Processing API to determine which values can appear here:
   *
   * - https://www.bytescale.com/docs/image-processing-api
   * - https://www.bytescale.com/docs/video-processing-api
   * - https://www.bytescale.com/docs/audio-processing-api
   * - https://www.bytescale.com/docs/archive-processing-api
   */
  transformationParams?: { [key: string]: ProcessFileTransformationParamsParameterValue };
}

export class FileApi extends runtime.BaseAPI {
  /**
   * Copies a file synchronously.
   */
  async copyFile(params: CopyFileOperationParams): Promise<CopyFileResponse> {
    const query: any = {};
    const headers: runtime.HTTPHeaders = {};

    headers["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/v2/accounts/{accountId}/files/copy`.replace(
          `{${"accountId"}}`,
          // @ts-ignore
          this.encodeParam("accountId", params.accountId)
        ),
        method: "POST",
        headers,
        query,
        body: params.copyFileRequest
      },
      undefined,
      [][0]
    );

    return await new runtime.JSONApiResponse<CopyFileResponse>(response).value();
  }

  /**
   * Copies multiple files asynchronously.
   */
  async copyFileBatch(params: CopyFileBatchOperationParams): Promise<AsyncResponse> {
    const query: any = {};
    const headers: runtime.HTTPHeaders = {};

    headers["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/v2/accounts/{accountId}/files/copy/batch`.replace(
          `{${"accountId"}}`,
          // @ts-ignore
          this.encodeParam("accountId", params.accountId)
        ),
        method: "POST",
        headers,
        query,
        body: params.copyFileBatchRequest
      },
      undefined,
      [][0]
    );

    return await new runtime.JSONApiResponse<AsyncResponse>(response).value();
  }

  /**
   * Deletes a file synchronously.
   */
  async deleteFile(params: DeleteFileParams): Promise<void> {
    const query: any = {};
    if (params.filePath !== undefined) {
      query["filePath"] = params.filePath;
    }

    const headers: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/v2/accounts/{accountId}/files`.replace(
          `{${"accountId"}}`,
          // @ts-ignore
          this.encodeParam("accountId", params.accountId)
        ),
        method: "DELETE",
        headers,
        query
      },
      undefined,
      [][0]
    );

    return await new runtime.VoidApiResponse(response).value();
  }

  /**
   * Deletes multiple files asynchronously.
   */
  async deleteFileBatch(params: DeleteFileBatchOperationParams): Promise<AsyncResponse> {
    const query: any = {};
    const headers: runtime.HTTPHeaders = {};

    headers["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/v2/accounts/{accountId}/files/batch`.replace(
          `{${"accountId"}}`,
          // @ts-ignore
          this.encodeParam("accountId", params.accountId)
        ),
        method: "DELETE",
        headers,
        query,
        body: params.deleteFileBatchRequest
      },
      undefined,
      [][0]
    );

    return await new runtime.JSONApiResponse<AsyncResponse>(response).value();
  }

  /**
   * Downloads a file in its original/unprocessed state.
   */
  async downloadFile(params: DownloadFileParams): Promise<runtime.BinaryResult> {
    const query: any = {};
    if (params.cache !== undefined) {
      query["cache"] = params.cache;
    }

    if (params.cacheTtl !== undefined) {
      query["cache_ttl"] = params.cacheTtl;
    }

    if (params.version !== undefined) {
      query["version"] = params.version;
    }

    const headers: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/{accountId}/raw{filePath}`
          .replace(
            `{${"accountId"}}`,
            // @ts-ignore
            this.encodeParam("accountId", params.accountId)
          )
          .replace(
            `{${"filePath"}}`,
            // @ts-ignore
            this.encodeParam("filePath", params.filePath)
          ),
        method: "GET",
        headers,
        query
      },
      undefined,
      ["https://upcdn.io"][0]
    );

    return new runtime.BinaryResult(response);
  }

  /**
   * Gets the full details (e.g. metadata, tags, etc.) for a file.
   */
  async getFileDetails(params: GetFileDetailsParams): Promise<FileDetails> {
    const query: any = {};
    if (params.filePath !== undefined) {
      query["filePath"] = params.filePath;
    }

    const headers: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/v2/accounts/{accountId}/files/details`.replace(
          `{${"accountId"}}`,
          // @ts-ignore
          this.encodeParam("accountId", params.accountId)
        ),
        method: "GET",
        headers,
        query
      },
      undefined,
      [][0]
    );

    return await new runtime.JSONApiResponse<FileDetails>(response).value();
  }

  /**
   * Processes a file and returns the result.
   */
  async processFile(params: ProcessFileParams): Promise<runtime.BinaryResult> {
    const query: any = {};
    if (params.artifact !== undefined) {
      query["artifact"] = params.artifact;
    }

    if (params.cache !== undefined) {
      query["cache"] = params.cache;
    }

    if (params.cachePerm !== undefined) {
      query["cache_perm"] = params.cachePerm;
    }

    if (params.cacheTtl !== undefined) {
      query["cache_ttl"] = params.cacheTtl;
    }

    if (params.transformationParams !== undefined) {
      query["transformationParams"] = params.transformationParams;
    }

    if (params.version !== undefined) {
      query["version"] = params.version;
    }

    const headers: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/{accountId}/{transformation}{filePath}`
          .replace(
            `{${"accountId"}}`,
            // @ts-ignore
            this.encodeParam("accountId", params.accountId)
          )
          .replace(
            `{${"filePath"}}`,
            // @ts-ignore
            this.encodeParam("filePath", params.filePath)
          )
          .replace(
            `{${"transformation"}}`,
            // @ts-ignore
            this.encodeParam("transformation", params.transformation)
          ),
        method: "GET",
        headers,
        query
      },
      undefined,
      ["https://upcdn.io"][0]
    );

    return new runtime.BinaryResult(response);
  }

  /**
   * Processes a file and saves the result.
   */
  async processFileAndSave(params: ProcessFileAndSaveOperationParams): Promise<ProcessFileAndSaveResponse> {
    const query: any = {};
    if (params.transformationParams !== undefined) {
      query["transformationParams"] = params.transformationParams;
    }

    const headers: runtime.HTTPHeaders = {};

    headers["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/{accountId}/save/{transformation}{filePath}`
          .replace(
            `{${"accountId"}}`,
            // @ts-ignore
            this.encodeParam("accountId", params.accountId)
          )
          .replace(
            `{${"filePath"}}`,
            // @ts-ignore
            this.encodeParam("filePath", params.filePath)
          )
          .replace(
            `{${"transformation"}}`,
            // @ts-ignore
            this.encodeParam("transformation", params.transformation)
          ),
        method: "POST",
        headers,
        query,
        body: params.processFileAndSaveRequest
      },
      undefined,
      ["https://upcdn.io"][0]
    );

    return await new runtime.JSONApiResponse<ProcessFileAndSaveResponse>(response).value();
  }
}

/**
 * @export
 */
export type ProcessFileCachePermEnum = "auto" | "false" | "true";
