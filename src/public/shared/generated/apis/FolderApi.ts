/* tslint:disable */
/* eslint-disable */
/**
 * @bytescale/api
 * Bytescale API
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: hello@bytescale.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

// @ts-ignore
import * as runtime from "../runtime";
import type {
  // @ts-ignore
  AsyncResponse,
  // @ts-ignore
  CopyFolderBatchRequest,
  // @ts-ignore
  CopyFolderRequest,
  // @ts-ignore
  DeleteFolderBatchRequest,
  // @ts-ignore
  DeleteFolderRequest,
  // @ts-ignore
  ErrorResponse,
  // @ts-ignore
  FolderDetails,
  // @ts-ignore
  ListFolderResponse,
  // @ts-ignore
  PutFolderRequest
} from "../models";

// Omitted by generator (so we add manually).
// @ts-ignore
import type { TransformationParams } from "../models";

export interface CopyFolderOperationParams {
  accountId: string;

  copyFolderRequest: CopyFolderRequest;
}

export interface CopyFolderBatchOperationParams {
  accountId: string;

  copyFolderBatchRequest: CopyFolderBatchRequest;
}

export interface DeleteFolderOperationParams {
  accountId: string;

  deleteFolderRequest: DeleteFolderRequest;
}

export interface DeleteFolderBatchOperationParams {
  accountId: string;

  deleteFolderBatchRequest: DeleteFolderBatchRequest;
}

export interface GetFolderDetailsParams {
  accountId: string;

  folderPath: string;
}

export interface ListFolderParams {
  accountId: string;

  folderPath: string;

  cursor?: string;

  dryRun?: boolean;

  includeFiles?: boolean;

  includeOverriddenStorage?: boolean;

  includePhysicalFolders?: boolean;

  includeVirtualFolders?: boolean;

  limit?: number;

  recursive?: boolean;
}

export interface PutFolderOperationParams {
  accountId: string;

  putFolderRequest: PutFolderRequest;
}

export class FolderApi extends runtime.BaseAPI {
  /**
   * Copies a folder asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.
   */
  async copyFolder(params: CopyFolderOperationParams): Promise<AsyncResponse> {
    const query: any = {};
    const headers: runtime.HTTPHeaders = {};

    headers["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/v2/accounts/{accountId}/folders/copy`.replace(
          `{${"accountId"}}`,
          // @ts-ignore
          this.encodeParam("accountId", params.accountId)
        ),
        method: "POST",
        headers,
        query,
        body: params.copyFolderRequest
      },
      undefined,
      [][0]
    );

    return await new runtime.JSONApiResponse<AsyncResponse>(response).value();
  }

  /**
   * Copies multiple folders asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.
   */
  async copyFolderBatch(params: CopyFolderBatchOperationParams): Promise<AsyncResponse> {
    const query: any = {};
    const headers: runtime.HTTPHeaders = {};

    headers["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/v2/accounts/{accountId}/folders/copy/batch`.replace(
          `{${"accountId"}}`,
          // @ts-ignore
          this.encodeParam("accountId", params.accountId)
        ),
        method: "POST",
        headers,
        query,
        body: params.copyFolderBatchRequest
      },
      undefined,
      [][0]
    );

    return await new runtime.JSONApiResponse<AsyncResponse>(response).value();
  }

  /**
   * Deletes a folder asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.  *When deleting a folder with external storage:* if the folder at `folderPath` has overridden storage settings (like an AWS S3 bucket), no files will be deleted, regardless of the parameters you pass. Only the mapping will be removed. If the folder at `folderPath` has inherited storage settings but includes subfolders with overridden storage settings, files in those subfolders won\'t be deleted, regardless of the parameters you pass. In summary, files in folders with overridden storage are never deleted, unless you directly delete a subfolder of such a folder.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
   */
  async deleteFolder(params: DeleteFolderOperationParams): Promise<AsyncResponse> {
    const query: any = {};
    const headers: runtime.HTTPHeaders = {};

    headers["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/v2/accounts/{accountId}/folders`.replace(
          `{${"accountId"}}`,
          // @ts-ignore
          this.encodeParam("accountId", params.accountId)
        ),
        method: "DELETE",
        headers,
        query,
        body: params.deleteFolderRequest
      },
      undefined,
      [][0]
    );

    return await new runtime.JSONApiResponse<AsyncResponse>(response).value();
  }

  /**
   * Deletes multiple folders asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.  *When deleting a folder with external storage:* if the folder at `folderPath` has overridden storage settings (like an AWS S3 bucket), no files will be deleted, regardless of the parameters you pass. Only the mapping will be removed. If the folder at `folderPath` has inherited storage settings but includes subfolders with overridden storage settings, files in those subfolders won\'t be deleted, regardless of the parameters you pass. In summary, files in folders with overridden storage are never deleted, unless you directly delete a subfolder of such a folder.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
   */
  async deleteFolderBatch(params: DeleteFolderBatchOperationParams): Promise<AsyncResponse> {
    const query: any = {};
    const headers: runtime.HTTPHeaders = {};

    headers["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/v2/accounts/{accountId}/folders/batch`.replace(
          `{${"accountId"}}`,
          // @ts-ignore
          this.encodeParam("accountId", params.accountId)
        ),
        method: "DELETE",
        headers,
        query,
        body: params.deleteFolderBatchRequest
      },
      undefined,
      [][0]
    );

    return await new runtime.JSONApiResponse<AsyncResponse>(response).value();
  }

  /**
   * Gets the full details (e.g. permission, storage layer, etc.) for a folder.  Returns an empty object if no settings have been configured for this folder.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
   */
  async getFolderDetails(params: GetFolderDetailsParams): Promise<FolderDetails> {
    const query: any = {};
    if (params.folderPath !== undefined) {
      query["folderPath"] = params.folderPath;
    }

    const headers: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/v2/accounts/{accountId}/folders`.replace(
          `{${"accountId"}}`,
          // @ts-ignore
          this.encodeParam("accountId", params.accountId)
        ),
        method: "GET",
        headers,
        query
      },
      undefined,
      [][0]
    );

    return await new runtime.JSONApiResponse<FolderDetails>(response).value();
  }

  /**
   * Lists the folder\'s contents.  The result may be paginated: subsequent pages can be requested by passing the ```cursor``` from the response into the next request.  Pagination is complete when the response includes `isPaginationComplete=true`.
   */
  async listFolder(params: ListFolderParams): Promise<ListFolderResponse> {
    const query: any = {};
    if (params.cursor !== undefined) {
      query["cursor"] = params.cursor;
    }

    if (params.dryRun !== undefined) {
      query["dryRun"] = params.dryRun;
    }

    if (params.folderPath !== undefined) {
      query["folderPath"] = params.folderPath;
    }

    if (params.includeFiles !== undefined) {
      query["includeFiles"] = params.includeFiles;
    }

    if (params.includeOverriddenStorage !== undefined) {
      query["includeOverriddenStorage"] = params.includeOverriddenStorage;
    }

    if (params.includePhysicalFolders !== undefined) {
      query["includePhysicalFolders"] = params.includePhysicalFolders;
    }

    if (params.includeVirtualFolders !== undefined) {
      query["includeVirtualFolders"] = params.includeVirtualFolders;
    }

    if (params.limit !== undefined) {
      query["limit"] = params.limit;
    }

    if (params.recursive !== undefined) {
      query["recursive"] = params.recursive;
    }

    const headers: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/v2/accounts/{accountId}/folders/list`.replace(
          `{${"accountId"}}`,
          // @ts-ignore
          this.encodeParam("accountId", params.accountId)
        ),
        method: "GET",
        headers,
        query
      },
      undefined,
      [][0]
    );

    return await new runtime.JSONApiResponse<ListFolderResponse>(response).value();
  }

  /**
   * Creates or updates the folder specified by the `folderPath`.  If the folder\'s ancestors do not exist, they will be created automatically (with empty FolderSettings).  Note: you don\'t need to create folders before uploading files to them.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
   */
  async putFolder(params: PutFolderOperationParams): Promise<FolderDetails> {
    const query: any = {};
    const headers: runtime.HTTPHeaders = {};

    headers["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/v2/accounts/{accountId}/folders`.replace(
          `{${"accountId"}}`,
          // @ts-ignore
          this.encodeParam("accountId", params.accountId)
        ),
        method: "PUT",
        headers,
        query,
        body: params.putFolderRequest
      },
      undefined,
      [][0]
    );

    return await new runtime.JSONApiResponse<FolderDetails>(response).value();
  }
}
